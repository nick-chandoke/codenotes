* instead of retaining relations of ordered structures, index them; when they reflect a desired order, add an index to each element, then perform whatever operations you want, then sort by the indices. if you must retain nesting (i.e. relations of relations) in the result R, then hopefully there's a way to express that easily enough by a multidimensional index, or index that's a sequence. as a last resort, you can store a uid for each element, and a separate structure S that stores the relations of uids, then use S to restructure R.
  ** in fact, a really nice coding style would be to express all data as graphs, and have a function `shape` that uses a graph of uids to shape any _set_ of vertices into a like structure. i imagine that a common idiom would be `dup [ ... ] with-shape`
  ** the separation of data from shape is one of the excellences of array languages. it allows us to elegantly subset, and to relate subsets.
  ** in sql, shape is given by relations (joins) of data; any data may be considered basically as an index simply by being in the join predicate. for efficiency, attributes may be ``INDEX``ed, but this does not affect semantics. sql's model of "sets of totally-ordered primivite data which may be shaped by that order" is most beautiful. recognize that this description entails JOINs, which are always done by comparison, i.e. by total ordering, including equivalence. to impart arbitrary order to data, simply impart an attribute whose values are arbitrary ordinals.
    *** one of sql's very few shortcomings is that it has no function to treat a set as a seq by incrementing or decrementing indices greater or less than an insertion index when, respectively, inserting or removing a subsequence.
  ** both sql and array langs support the description, "if my computation only concerns the elements and not their shape, then i shouldn't have to specify their shape!" `[ [ ... ] map ] map` _is_ pretty dumb!

.reactive programming is just declarative programming

i started off with the idea of making a function on a sequence into one that works incrementally i.e. that, when new data arrives, updates only as many data as it must. this is to make it support an "increment" operation such that only the minimum subset of state/data is computed upon. the "incremental update" scenario has 3 parts: the trigger event, the updated part, and the non-updated part. more generally, it's just a system of triggers. much like incrementing a number and overflow causing increment of the next-highest digit, any system is one part affecting others upon a certain event. this is just reactive programming, or, as i like to call it, "programming", since it's the same damn thing! to say "A triggers B" is to say "upon event A (either io or evaluation of an arbitrarily-delimited computation), `... [ B ] when`". reactive programming is just declarative programming, which is just to describe all computations as a set of edges, thereby implying a graph, rather than specifying the graph as a DAG with loops i.e. as a program i.e. a SEQUENCE of instructions where some of the instructions are loops (thus making cycles) or combinators (thus being a DAG)!
