= when direct arithmetic is best for coding (it's often)

NOTE: this "coding" method (see "coding.adoc") based on arithmetic, information theory, and development with regard to the machine's architecture, which i discovered & developed myself, is apparently already a known practice called link:https://vimeo.com/649009599?fl=pl&fe=ti["data-oriented design/programming"]. i've only just discovered this term, so i have yet to compare my perspective with common knowledge. i basically developed my method from apl (all data is arrays of numbers, and we exploit number theory to the hilt). also see link:https://github.com/simongog/sdsl-lite/wiki/List-of-Implemented-Data-Structures[the succinct data structure library].

.terminology

`and` & `or` should be called `both` & `either`—or even better than these binary versions, their n-ary versions _all_ & _any_—at least when one is first learning/introducing the concepts. even by the time one gets to boolean rings, they should be "product" & "coproduct", though "and" & "or" are terser....  really, "any" & "all" are clearest, which naturally mean, for booleans, "any or all [of the nth bits is/are set]."

.some factor stuff

[source,factor]
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
! using a timestamp tuple object
: mins-since-midnight ( timestamp -- mins ) [ hours>> 60 * ] [ minutes>> ] bi + ;

! direct translation into arithmetic version
: mins-since-midnight ( millis -- mins    ) 60000 /i 60 /mod [ 24 rem 60 * ] dip + ;

! actually sensible version when one reasons from arithmetic originally
: mins-since-midnight ( millis -- mins ) 86400000 rem 60000 /i ;

! timestamp version, where ``midnight``'s expanded definition is `clone 0 0 0 [ >>hour ] [ >>minute ] [ >>second ] tri*`
! obviously the arithmetic version is simpler, has fewer instructions, is shorter, and is trivially portable to any programming language, including risc assembly
: midnight/millis ( millis -- midnight ) 86400000 [ /i ] keep * ;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

much better than converting into a `timestamp` tuple [oop] just to convert back to milliseconds. furthermore, i can store unix timestamps as words [asm] on 64-bit systems, which means that i can store them in static arrays without pointers.

.map from numbers to two booleans

sure you could use a hash table from a number to an ordered pair or whatever of booleans, but sometimes we can do better. for example, i found a need to map numbers from 0~53 to two booleans. each boolean corresponds to one bit of information, so two booleans is two bits. 53 is less than 64, so i can, on a 64-bit architecture, use a dword to store 53*2 bits of information. then to get the two bits at a given number _n_, all i must do is `THE_MAP >>> (n*2) & 3`. as it turns-out, here's the map:

------------------------
key    bool 1    bool 2
----  --------   -------
   1        1         1   
   2        0         1   
   4        1         1   
   5        1         1   
...
  37        0         1   
  38        1         0    
  41        1         1   
  52        0         1   
  53        0         1   
------------------------

to build the map/number:

[source,c]
-----------------------------------------------------
unsigned long long map;
int A[n][3];
for (int i = 0; i < n; i++)
  map |= (A[i][0] * 2) << ((A[i][1] << 1) | A[i][2]);
-----------------------------------------------------

idk if that c is exactly correct, but hopefully you get the idea. and, yeah, instead of multiplying by 2 you can shift right 1, but i wanted the code to be semantically obvious. i did the actual coding in factor: with the matrix on the stack, `0 [ first3 [ 1 shift ] dip bitor swap 2 * shift bitor ] reduce`.

anyway, the result is this heccin' chonker: 0x500000c27fff7ccf50035ff4f1c. we can get the 2 booleans for e.g. key 34: `0x500000c27fff7ccf50035ff4f1c 34 -2 * shift [ 2 bitand 2/ ] keep 1 bitand`. we can test that the encode/decode works: with the matrix on the stack: `dup [ first dup 0x500000c27fff7ccf50035ff4f1c swap -2 * shift [ 2 bitand 2/ ] keep 1 bitand 3array ] map =` returned true.

.representing stock market status

i could use symbols, but i can use arithmetic in a lovely, natural way:

[options="header"]
|=================
| binary | meaning
| 00     | closed
| 01     | am
| 10     | day
| 11     | pm
|=================

* the empty value 0 is semantically natural with "closed"
* the codes' order corresponds to temporal progression
* the rightmost bit tells whether we're in extended hours or not

an interesting thing about this pattern is that, if we want to build this number from 3 booleans (we get 0 if none), first we assign incrementing ordinals to them, then we could OR them all together, or we could just take their max: `(am*1) | (day*2) | (pm*3)` or max(am*1,day*2,pm*3). here, as is very common, we see `or` & `max` both as "coproduct". we could've used addition instead, just as well, just another coproduct. in fact, if we use addition instead of `or`, then the experssion is the usual dot product.

this situation has the pattern that at most one of these booleans can be true, so in apls, where bits are represented as boolean vectors, we can just prefix with a zero then select the index of the first truthy bit e.g. in k: `0^0 0 0 1?1`. we need `0^` to convert `0N` (null, a value returned if none was found) into a zero. also, iirc, the x86 architecture has an instruction to return the index of the left- or right-most set bit. i mean that'd be useless as redundant, since to get that bit we would have already had to OR them together, which gives the same result anyway. but still, good to think about, since if our situation were just a bit different, it could be useful.

== outside arithmetic

the use of arithmetic as a design generalizes: exploit special _values_ rather than creating new constructs. an example is to use 0 or NaN where otherwise one might think to use `Maybe Int`. in text editing, one might want to use a template system in emacs: you press a key, and a text template is inserted under the cursor, and the fields-to-be-filled are highlighted by yellow rectangles, and the cursor is positioned over the first box, and then you press "enter" to move the cursor to the next box until all are filled. cool, but why put in the effort to implement such a system when you could instead just insert a template as ordinary text, but have blanks expressed as "____"? to fill the template, start by leaving the cursor where it is, at the start of all this text, then search for "____", fill that value, then press 'c' to delete the blanks and enter insert mode, fill the value, hit 'escape' to go back to normal mode, then repeat. sure you have to press "esc n c" instead of just "enter", but that's really inconsiderable, and this method is simple. we didn't have to implement functionality by _code_; we implemented functionality by _values_ & apt use of common text editing primitves.

this is basically the same fact as using data instead of higher-order functions e.g. in j, `x u/.y` (group by `x`) uses grouping vector `x` instead of taking a grouping function. usually `x` will be (the result of) some function of `y`. why mandate that we apply on operation to `y`? granted, if we do, then we can just specify the identity function, but isn't it dumb to say "we're going to apply an operation but that operation is a no-op?" just don't mandate the operation!

== summary

i imagine that many people who look at apl code think that it's very "janky" or "hacky" to use numbers for values rather than control structures, as though language is better than numbers. but this is quite the opposite; numbers are a _better alternative to_ language features! they represent the same information but more elegantly since they're computable values. it is _not_ that the languages are wanting for language features or syntaxes and _therefore resort to_ using numbers! the heavy use of arithmetic & numbers is intentional, elegant, efficient, and desirable. by using numbers well, there's little need for language features.

also, code that uses numbers is symmetric, mathematically elegant. consequently, we can't use arithmetic to e.g. check valid user input. this being said, if the user is a dumbass, then they deserve their own demise. user-friendliness is to make the program easy to use correctly, not to prevent improper use! it's no better to have the user select, via a curses interface, from a list or combobox, than it is to display a table of numbered choices, having the user enter the number corresponding to their desired choice. if the user enters an invalid input, then let the program segfault or whatever. god help them if they can't do even that. perhaps computers are "just not for them." on my toaster, the part where the bread goes says, "caution! hot surface. do not touch" or whatever. there isn't a guard there to prevent me from sticking my fingers into my toaster, not only because no such "no hand, only bread" pass-through filter is conceivable, but because why the hell would they, because why the hell would i.
