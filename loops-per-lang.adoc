* in c, `while` has separate test & body clauses b/c the body doesn't return a value; it's just code that executes. therefore it must mutate some of the test clause's state in order for the loop to execute a finite, positive number of times.
* in factor, with the stack, the stack _is_ the state, and has mutiple values. `loop` is appropriate.
* factor's or k's `while` is the nonsense case: they retain c's two clauses despite the body returning a value which is then tested by the test clause. the two clauses, which are expressed as higher-order functions, can be composed, thus arriving at factor's `loop`. however, unlike factor's `loop`, having two separate clauses needlessly introduces scoping issues and, sometimes, the need to pass multiple values between the two clauses. of course, the easy way to do this, in lexically scoped languages (not apls), is to do like c: declare a mutable variable to be used in both clauses, in the same scope as both clauses, then mutate it in the body. if we do this, though, then having the body return anything is senseless. and indeed, if the body maintains multiple data, then one must return multiple of them, where none is significantly different from the others. in non-stack langs, dealing with multiple outputs is a pain; it's much easier to just mutate some state, letting it naturally be present in multiple lexical contexts.
  ** this is an example of arbitrary division, btw

really, purely mutative languages are the only sensible choice. one may argue that functions naturally arise from the passing of intermediate states to multiple computations, but this is actually expressed exactly by combinators, whereas functions can express it, but less elegantly, and while adding extra, unhelpful designs.
