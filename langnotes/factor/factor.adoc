== factor

[TODO]
* concurrency
* cf joy viz binrec or lacking lambdas. the combination of being stack-oriented _and_ being tacit might be particularly interesting....
* cf link:https://forth-standard.org/[forth] viz wrt efficiency

continue on page 49 of factor.pdf

=== design

* like scheme ([non-pure] functional, code is data (quote & eval, custom syntaxes)) but:
  ** backslash is needed to refer to a fn without execution e.g. `\ drop` pushes `drop`; `drop` alone would execute it. `\ drop` is different from `[ drop ]`.
  ** no parens!
  ** quotations are sequences
  ** easily examine the whole program state in the debugger
  ** can pass around macros like any other data
  ** good, _flexible_ (somewhat implicit by generic words, mixin classes & instances) oop support (like cl)
    *** this is how we do ad-hoc relations. this makes encoding ad-hoc polymorphism easy, so we can have haskell-like concision but without haskell's restrictions.
      **** programs are often prolog-like: small facts (except here fns) that are used like a vocabulary; more code re-use than big, specialized chunks of code.
  ** stack instead of applicative
* NB. named local binds is implemented as a factor macro (so they're expanded before runtime). same for square and curly brackets, quote marks, and colon for fndefs. (meta-circular)
* code is compiled on the fly into highly optimized single static assignment (SSA IR). such a simple lang supports extreme optimization.
  ** use `optimized.` (instead of `.`) to see optimization details of some code
* extremely good ide: simple, debugger/stepper, inline docs (all local), quickly see everywhere that any word is used, and any word's definition
* uses arrays with pseudo-indexing (i->a) e.g. `<reversed>`
* has a PEG lib! (uwu) (`EBNF:`) furthermore pegs are for SYNTAX!
* comes with memoization library
* λ syntax is `::`
* good unicode support
* supports dynamic scope!
* debugging steps through ops and shows the stack at each op
* postfix; read left to right, e.g. `2 even? [ "OK" ] [ "Cosmic rays detected" ] if` for `2|2 ? "OK" : "Cosmic ..."`
  ** pipeline [unix cmd pipe] design
* design influenced by forth, joy, cat, oop, metaprogramming
* like lisp, factor is made for dynamicism: scripting, macros, and repl.
* like haskell, data are just nullary functions
  ** all syntactic objects are simply called _words_
* all control flow is `if` branching or recursion
  ** both branches of `if` must have the same stack effects
  ** factor guarantees tail-call optimization!
* excepting row-polymorphic combinators and macros, all words must accept and output a fixed number of words
* latently typed
* has static stack checking in addition to dynamic type checking
* program is words pushed to the stack from left to right, which is naturally also function composition (like other stack langs)
* modules are called _vocabularies_
  ** for maximum flexibility & interactivity, even private identifiers are usable in greater contexts if explicitly referenced
  ** like java public classes, each vocabulary must be defined in a file of the same name
* factor is oop, but all methods are generic
* uses _virtual sequences_, i.e. functions from index to element

=== env

* `USE: <lib>` imports a lib. `USING: <lib> ... ;` imports many.
* see `QUALIFIED:`, `FROM:`, `EXCLUDE:`, AND `RENAME:`, too.
* `IN:` defines a module

=== semantics

* pushing quotations does not use memory

=== the repl (the _listener_)

* runs as a gui rather than cli program
* is a client that connects to a repl server
* tracks the stack for you, which makes easy both working with state and debugging
* to enable dark mode (no idea how this was found): run `USE: tools.scaffold scaffold-factor-boot-rc` then add `USE: ui.theme.switching dark-mode` to `~/.factor-boot-rc`, then run `run-bootstrap-init save`, then restart the listener. on nixos i got a _read-only filesystem_ error, so this didn't work totally.

=== syntax

[source,factor]
----
! starts comments
----

* spaces are required adjacent to delimiters; otherwise, like lisp, they're seen as part of an identifier
  ** this isn't generally true; that's just how these delimiters were implemented. delimiters are factor macros.

|===========================
| {}             | array literal
| []             | quotation (like lisp)
| '[ ... _ ... ] | threading macro, e.g. `5 '[ _ + ]` is equivalent to `[ 5 + ]`. requires `fry` library.
|===========================

==== word definition

[source,factor]
----
: foo stack-effect
  body ... ;
----

where `stack-effect` is the syntax `( input ... -- output ... )`

* the stack effect is for documentation and stack checking only. it's required syntax.
* indentation is purely conventional. `:` & `;` delimit definitions

===== row-polymorphic definitions

`each` has effect `( seq quot -- )`. `quot` may be any effect that balances correctly, e.g:

* `( x elt -- x' )`
* `( x y elt -- x' y' )`
* &c

e.g. `quot` can be a function from one value to one value, or two to two, &c.

* `..a` identifies a row-polymorphic variable, where `a` is any character, and may appear in inputs or [inclusive] outputs
* quotation inputs can be given stack effects by form `name: ( input ... -- output ... )` and row vars in those nested effects will be unified with row variables of the same name in the outer effect or other nested effects.

.fully-expanded stack effect of `each`
[source,factor]
----
( ..a seq quot ( ..a elt -- ..a ) -- ..a )
----

=== oop/generics

probably the easiest & most flexible oop ever:

[source,factor]
----
TUPLE: circle r ;
TUPLE: rect l w ;
GENERIC: area ( shape -- area )
M: circle area r>> dup * pi * ;
M: rect area [ l>> ] [ w>> ] bi * ;
----

* >>foo writes, foo>> reads.
* what are
  ** multiple dispatch (planned inclusion in factor, but currently implemented by a library)
  ** predicate classes
?

three functions from class to class:

* derivation
* union (n-ary)
* intersection (n-ary)

three types of classes:

* primitive
* tuple
* derived
* predicate (subclass B of A where A consists of instances satisfying a predicate)

primitive & tuple classes use >> & << (but not derived ones?)

=== common fns ("words")

.s:: print stack
.:: pop & print that which was popped
clear:: clear stack
drop:: pop
nip:: remove 2nd stack item

==== stack shuffle

uses haskell as-patterns and ellipsis represents [part of] the stack. implicit in this notation is the fact that the word is at the top of the stack before being evaluated.

f:: fn
q:: quotation

|====================
| drop  | ... x -> ...
| dup   | ... x -> ... x x
| over  | ... x y -> ... x y x
| swap  | ... x y -> ... y x
| dip   | ... x q -> (q ...) x
| keep  | z@(... x) q -> (q z) x
| curry | ... x q -> ... (λX. q x X)
|====================

* remember that input & output names are programmatically unrelated (what does this mean?)

mentally tracking stack effects is troublesome. you should use three easy-accounting fundamental combinators:

[options="header"]
|======================================================================================================
| word   | description                            | example
| cleave | apply multiple operations to one datum | 5 { [ 1 + ] [ 2 - ] } cleave -> 6 3
| spread | pointwise application                  | "A" "b" { [ >lower ] [ >upper ] } spread -> "a" "B"
| napply | apply an operation to n stack items    | "A" "B" [ >lower ] 2 napply -> "a" "b"
|======================================================================================================

bi & tri combinators are a bit more convenient: they eliminate braces or a number argument:

* `bi` & `tri` are 2- & 3-cleave
* `bi*` & `tri*` are 2- & 3-spread
* `bi@` & `tri@` are 2- & 3-apply

==== control flow

|==================================================
| when   | ... x q -> ... ! side effect q run if x
| unless | negation of when
| if     | ... x q u -> ... ! run q if x else run u
| when*  | ... x q -> ... x ! when but leaves x
|==================================================

==== common higher-order fns & loops

* `each`, `map`, `reduce` (fold), `replicate` (scan), `accumulate` (pushes (scan w/o last elem) and (fold's last elem))
* `x f g produce` scans g over x until not f. while is same but fold rather than scan.

==== unique to factor

[options="header"]
|=================================
| word or syntax | meaning
| : [...] ;      | define new word (literally `:` sets factor in compile mode until `;`
| --             | stack effects
| :: [...] ;     | `:` but either stack effect symbols are locally bound vars or are bound by `val :> id` clauses before the body. requires importing `locals` vocab.
|=================================

* `[| m n | m n + ]` binds m & n to 2nd and top stack elems, then uses them to push m+n.

.mutable vars example
[source,factor]
----
USE: locals
! 3 f => 11
:: f ( x! -- t ) ! x! makes x mutable by enabling x! to set x (see below)
  x 2 * x! ! x<-2x
  5 x + ;  ! return 5+x
----

`x!` pops into `x`. exclamation marks ("shrieks") are particular here.

===== globals

[source,factor]
----
SYMBOL: x      ! declare
4 x set-global ! set
x get-global   ! access
----

=== examples

each example here is a 1-liner

[source,factor]
----
{ 1 2 3 4 } 0 [ + ] reduce
{ "hello" "there" "boi" } [ print ] each
[ "#" head? not ] filter [ string>number ] map 0 [ + ] reduce
----

.tail, naïve, and sequence factorial
[source,factor]
----
: tail-factorial ( acc n -- n! )
  dup 0 =
  [ drop ]
  [ [ * ] [ 1 - ] bi tail-factorial ] ; [ * ] [ 1 - ] bi = λx. x*(x-1)
  if ;

: factorial ( n -- n! ) 1 swap (factorial) ;

[1,b] product # not even defined as its own function b/c it doesn't need to be; it's not recursive
----

=== caveats

* `print` doesn't accept numbers (generic word `string-lines` does not define a method for the fixnum class)

=== libs

* for graphics, use cairo; it has bindings to factor
