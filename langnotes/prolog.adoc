== prolog

TODO: explore prolog vs SAT & SMT solvers and theorem provers; how can prolog, which is metaprogrammable and defined only of constraints, not be the most general programming language?

.current yet consideration

* uses predicates which are better than ADTs & type classes because they're more fundamental
* declarative & algebraic: user specifies algebra-defining facts, then queries those facts. typical languages implicitly specify algebraic rules by traversals. the art of writing traversals has become one of the main programming skills. both data structures (which are built or traversed by traversals) and algorithms (traversals of structures, even of tuples like (m,n)) are considered in a myriad of ways, trying to find the most elegant arrangements for any given problem. like poetry, it is an art and can be appreciated for its beauty, but is as appropriate as trying to use poetry for technical documentation. furthermore this style of programming by arranging structures and traversals is considered vaguely with regard to a wide range of use cases; the structures and defined, as are variants (e.g. `foldl`, `foldr`, `foldl1`) just to more conveniently express solutions for _supposed_ problems. by contrast, prolog (and other dedective or declarative models) define only, explicitly the facts, and do not try to anticipate how those facts will be considered, for certainly there are too many nuanced varieties of considerations! the non-logical (oh, what an apt name!) programming style sees a clumsy mix of: idioms; design patterns; structures, traversals, and couplings and abstractions thereof (e.g. type classes or functions that're basically idioms); and finally, when all those fail, primitives are there for the developer to fall-back to. the only sensible variety of such a style of programming is to use virtual graphs (which are isomorphic with a database of facts) as the only data structure (and graphs generalize all other structures), and primitives—namely arithmetic primitives (elementary & bitwise), `eval`, and get & put.

=== model

* _predicate_ (_symbol_) is the basic object in prolog. the notation p/n means an n-ary predicate. in logic terminology p(...) is called an _atom_; in prolog it's called a (simple) *goal*. in prolog _atom_ means a constant symbol. 
  ** a _rule_ is a predicate defined of others e.g. `grandfather(X,Z) :- father(X,Y), father(Y,Z)`
  ** a _fact_ is a unary predicate
  ** a _ground fact_ is a nullary predicate. _ground_ generally means _nullary_.
  ** a _clause_ is a rule or fact
* `p(a,b)` can be interpreted into relalg as row (a,b) in relation `p`.
* uses implicative definitions: `x := def` is seen as `x :- p1. x :- p2. ...`

==== wrt relalg

[options="header"]
|=====================
| prolog    | sql
| goal      | query
| rule      | view
| predicate | relation
| variables | lacks variables
|=====================

though sqlite supports query variables via `%n` or `?` syntaxes, i've yet to check whether this is as expressive as prolog. how well do they work for complex queries?

recursive predicate example:

[source,prolog]
----
ancestor(X,Y) :- parent(X,Y).               % base case: parent is the shortest ancestor relation (edge)
ancestor(X,Z) :- parent(X,Z) ancestor(Y,Z). % recursive case (path)
----

such recursion, which is really accomplished by backtracking, since any recursion is implicit, is prolog's only canonical looping, and more generally control flow, mechanism, aside from cut. it is technically recursion, but abstractly so, not specifically _recursion_ in the common computer science sense of functions calling themselves, pushing to a call stack. i imagine that execution of queries is a `while` loop with global state.

=== semantics

[TODO]
* is there a better way than cut to encode exceptions (namely to partition a single rule, taking it from one/symmetric to multiple/asymmetric)?

prolog has a main, commutative, binary operation called _unification_, represented by `=`: if both sides are bound e.g. `2 = 3`, then equality is checked; if one arg is free then it's bound to match the other arg e.g. `X = 3.`; if both args are free then relation is put into fact set e.g. `X = 2, X = Y.` (i.e. X = Y = 2.)

`X = 3 + 2` is incorrect; `X is 3 + 2` is correct. `=` is for solving only, not assignment. the rhs of `is` _must have no free vars_. TODO: what does this mean? i ask b/c the following is valid:

[source,prolog]
----
nearby(X,Y) :- X = Y.
nearby(X,Y) :- Y is X+1.
nearby(X,Y) :- Y is X-1.
----

note that prolog is totally flat; no nested structures are needed to describe a program. specifying predicates is like specifying an rdf db.

any unification, and so any predicate, either succeeds with possible binding, or fails, guaranteeing no new bindings.

a variable passed to a unary predicate is guaranteed to be bound when considered in conjunction with other predicates.

* *clauses are tried in declaration order*. therefore base cases must always preceed recursive ones.
  ** clause order is irrelevant in datalog
* the `print` predicate prints its argument at its time of evaluation. useful for debugging. e.g. `magicNumber(X), print(X), X > 40.` prints 7 9 42 X = 42. 7 & 9 were tried but failed, so prolog backtracked until it got to 42, which succeeded the predicate.
* the way that prolog evaluates: each predicate p~i~ returns multiple solutions _S_; one is then tried against the next predicate p~j~, backtracking to try the next value in _S_ if it fails p~j~.
* prolog uses the _closed world assumption_: if a thing cannot be proven true, it's assumed false, even if it _may_ be true, which would be knowable if we'd'd more info. in this way the empty set translates to false, which propogates. hopefully you can specify more facts to support greater implication. i suppose that a complete definition would imply all theorems....
* query (with variable) execution will, at least in a repl, return answer(s); if user presses `return` then repl awaits new query. if user presses `;` then another answer is searched for. `.` accepts an earlier solution.
* variables are never declared; like prolog identifiers, all exist and can be referenced as freely as any numeric literal
* lists are like haskell. functions (predicatesg of lists are defined like multiiple pattern-matching haskell definitions
* `=..` appears to be like lisp's `eval` & `quote`

prolog is metaprogrammable because its queries are themselves horn clauses i.e. the executor is of the same form as the executed. sql does not support storing queries as relations in such a way that the result of a query is itself an executable query.
one of prolog's advantages over sql is on-the-fly relations e.g. `point(1,2)`, which in sql is `create table if not exists point(x integer, y integer); insert into point values(1,2);`. obviously sql lacks support for anonymous objects and expressions, and expressions are not computable objects in sql. furthermore statements like `create table if not exists` would be rife in a literal translation of prolog to sql. `line_seg(point(u,v),point(x,y))` has an even uglier sql translation! all such problems are easily fixed by wrapping sql in an dsl, preferably in factor, which can statically reduce the actual sql instructions into an efficient form. especially with prepared statements, we see sql(ite) as a relalg lib more than a standalone language; perceived as such, sqlite is brilliant! sql or prolog should be considered as a table/graph with convenient traversal combinators. the simplest model of a traversal, and so one that i currently promote, is a state & query where the state is kept separate from and reïfies the query per iteration: `( q: ( query state -- ..b ) query state -- ..b )` defined by `loop`.
in prolog, functions are defined implicitly as (dom...,cod) tuples. with recursion we get universal qualification (symmetric definitions), and with multiple definitions, we get existential quantification (ad-hoc definitions). the reversability of programs gives great beauty, such as `member` both testing membership and specifying it, e.g. `member(a,L), member(b,L)` to implicitly mean any list containing `a` & `b`; or `append` simultaneously defining it and `split`; or that defining `length`, to get the length of a list, can be used to produce an list of variables of given length. *every definition implicitly defines its dual.*
sillily, the main feature that makes prolog so powerful is that it uses _symbols_ instead of _identifiers_; unlike in most langs, a symbol is itself, not reïfied to some value. symbols can be computed, like a cas factoring a polynomial. so prolog's good ability is simply in its chose to _not_ do what other langs do unnecessarily! namely, prolog defers instantiation of its symbols as much as possible. in a functional language, functions are first-class. in factor, that's encoded as quoted functions, a specific case of quoted programs; in factor, programs [expressions] are first-class. in prolog, not only are programs first-class—they are the sole objects! horn clauses are the sole expression in prolog! thus in prolog, metaprogramming equals programming, and data equals code; a prolog program is merely a sequence of horn clauses, and the "execution" of that program is a _de facto_ traversal of that data done by the interpreter. this is true of prolog but not factor because factor is not composed only of programs! it is also composed of data; the problem is that factor reïfies values rather than working _only_ with programs. ...i think? i mean, factor is a stack machine, which is less expressive than a logic db; is _that_ actually the reason that factor is inferior to prolog?

=== syntax

* `;` separating two clauses means coproduct. it's semantic sugar for distributing over the disjoint set.
* identifiers begin with capital letters or underscores (excepting special token `_`)
  ** prolog's internal anonymous vars are of form /_[0-9]+/
* constants are denoted as: numeric literals; or strings of special characters; or starting with a lowercase letter; or single-quoted strings; or [] (optional space between brackets)
  ** single quote literals are denoted by '' rather than what would commonly be \'
* predicates specifications and queries are both ended by a dot. a predicate without parens is nullary.
* commas denote product of two (sub)goals e.g. `father(paul,X), father(X,Y)` such goals are called _compound queries_
* `[fp]` imports filepath `fp`
