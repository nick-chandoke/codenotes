_computing_ is just interaction. what are commonly known as "computers" are no more particularly computers compared to any other interaction. they are notable, however, in that they're _programmable_ i.e. that manipulating them to do arbitrary desired tasks is easy.

all meaning is relation. therefore all computation is relation. all relation is symmetric or asymmetric. computation over asymmetric relations entails branching i.e. a computation per branch, and each branch is an asymmetry. asymmetries are partitions of symmetries i.e. some thing is by default symmetric, but when it's subsetted so that each subset can be related to a different computation/consideration, then it's been "broken into asymmetries." the once-symmetric structure is now _considered_ asymmetrically i.e. we've decided to *interpret* it so that its *meaning* is given by asymmetries. remember that data are matter, and computations are form i.e. relation i.e. meaning. we may call it "data", "code", or "information", but it's all the same thing. it's the "stuff", the matter, and matter itself can form other matter, and so of course even rectangles are parameterized by width & height, and can be generalized to other forms such as closed figures, which may have any number of sides or constraints, and can be generalized to curves simply by introducing more, special point parameters, such as bezier curves, and thus we have mutation of structure itself just as well as the mutation of the structure's constituent data.

value is value. values can be distinct (symbols) i.e. support equivalence, and i haven't explored that too much yet, but additional structure—order—is what gives us "numbers" and by "numbers" i mean "any totally-ordered value" e.g. naturals, reals, or sequences thereof, such as strings, which are just sequences of codepoints or otherwise of values supporting an alphabetical ordering. complex numbers may be totally ordered, but we decide for them not to be; only each of their components is ordered. these particular rules (algebra) that we enforce of complex numbers (i.e. that which makes an ordered pair a complex number) is fine, but note that it is a limation of computation. constraint can afford us efficiency, guarantees/provability, and hone our focus, but it constrains. always be careful the degree to which you constrain i.e. resist mutation. it can be useful, but it can limit you from discovery.
