.`if` considered harmful

use `case`/`switch` instead. in a nutshell, `switch` is declarative and `if`/`cond` is procedural.

it's actually already being done: haskell's `if` is syntactic sugar for `case` on `True` & `False` constructors of the Bool sum type. `switch` syntax should be terse; for example, `x:: 1: a; b;; 2: c;` for what in c would be `switch(x){case 1: a; b; break; case 2: c;}`. this is no longer than an `if` statement. in a tacit, concatenative language, it could be just `1:[ a b ] 0:[ c ] sw` vs `[ a b ] [ c ] if`. the syntax could simply be that, like c enumeration syntax, if case numbers are omitted then natural numbers are assumed, starting from the last-declared case number (so the false branch would precede the true one). rather than store multiple booleans as vars by name or in the stack, mask them together then run a `switch` statement. this is flat and makes tracking all booleans explicit and thus easy. for example:

.oldest version

TODO: put here from backup

.old version (sketch; get the basic feel for it)
[source,factor]
---------------
pluggedin?
[ getcharge 98 >= [ ... drop f ] [ drop t ] if ]
[ getcharge [ >= ] curry MY_ARR swap find drop 3 or ! in k this whole line is expressed simply as 1+MY_ARR'getcharge[]
  [ 0 =
    [ ... ]
    [ ... ] if
  ] [ drop ] if
] if
---------------

TIP: using link:https://code.jsoftware.com/wiki/Vocabulary/icapdot#dyadic[bins] (') returns a natural number, which puts it into the magical land of natural number arithmetic, so i can bitshift and use switch/case. thanks to apls for making bins a primitive to encourage its use!

.new version
[source,factor]
---------------
NEXT
---------------

using numbers afforded me to refactor from the oldest to newest versions because it reduced complexity both in that there were fewer variables to track, and simpler control structure i.e. mentally tracking which data is on the stack and in which order, or which booleans hold in a given conditional branch, and in factor, balancing `if` branches to have equal stack effect. you still must ensure equal effect of `case` branches, but it's much easier since both 1. `case` is flat, and 2. one input is tested against each case branch, whereas each `cond` branch's effects depends on its predecessor's branch's effect.

one might erroneously think that the old version could be equivalently rewritten by combining into a single test case: `getcharge 98 >= pluggedin? and` then inlining it with the other `if` branches, all expressed as one `cond`, but that would be wrong because most of the clauses actually require that we are _not_ plugged-in. if we incorporate the `pluggedin?` bool as a bit in a number, then we immediately know from the case number whether, in that case, we're plugged in or not; in other words, it makes each case, independently, an effortless & elegant expression of all of which booleans are true and all of which are not, altogether/simultaneously.

btw, `switch` has better execution time than `cond` since it's just a lookup in a table rather than multiple conditional branching.

other concerns which i didn't notice in this case, but i've encountered before:

* type safety won't help me notice whether two booleans are accidentally swapped! that kind of error is much easier to make than incorrectly masking together booleans!
* reordering case [switch] statements (assuming that none falls-through to the next) doesn't change the program. reordering `cond` branches does, since each branch is with respect to its predecessors. also case is flat, so rearranging its source code is much easier than rearranging nested `if` clauses!

.limitation of `switch`

consider 4 booleans `a b c d` of values `t f t t`, and their compound representation x:1011~2~. if you want to test specific combinations of the 4, but also want to test combinations of only a proper subset, e.g. `a|!d` then you could enumerate up to all 32 cases, which, with fall-through and `default` might not be too bad, but you can see how this becomes problematic for 4 or more booleans. in this case, we could use cond wherein each or most branches have a switch on a subset of values e.g:

[source,c]
-----------------------------------------------------------------
switch(x & 0b1001) { // select only a & d from x i.e. normalize b & c to 0
  case 0b1000 | !0b0001: // a | !d i.e. 0b1110
  ...
  y = 1;
  break;
}

if(!y) {
  switch(x & 0b0110) { // select only b & c from x
    case 0b010: ... // (!b)|c
  }
}
-----------------------------------------------------------------

TIP: AND is the natural joining method; "it's raining. it's cold." is the same as "it's raining and it's cold." or (disjoint union) is a less-common case. 

i advocate `switch` instead of `cond` because it's flat: branch order is meaningless (except fall-throughs) and each case value contains all the information so you don't have to look elsewhere nor track which conditions failed or succeeded by the time that you test the case. if you use `cond` such that order is irrelevant (i.e. each cond test clause contains all data used across all test cases, explicitly including whether each is true vs false) then it's just as well to use cond. the switch technique certainly works well for 3 or fewer booleans, which is a common scenario.

.fall-through

to map a set of values to a computation, omit `break`:

[source,c]
------------------------------
switch(x){
  case 1: case 3: case 5: case 6: case 8: ...; break;
  case 9: ...; break;
  case 11: ...; break;
  default: ...; break;
}
------------------------------

of course, if c had better syntax, then it'd just be:

[source,c]
------------------------------
switch(x){
  1 3 5 6 8: ...;;
  9: ...;;
  11: ...;;
  default: ...;;
}
------------------------------

the "switch" idiom can be effortlessly ergonomic, if only sensible syntax is chosen.
